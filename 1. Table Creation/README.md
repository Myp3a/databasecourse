# Задание 1
## Содержание
 - [Создание таблиц](#Создаем-таблицы)
 - [Заполнение таблиц данными](#Заполняем-таблицы)
 - [Заключение](#Заключение)

# Создаем таблицы
## Студенты
Начинаем с создания таблицы для хранения студентов. Первичный ключ таблицы - номер зачетки.  
### Атрибуты:
 - Номер зачетки
 - Имя студента
 - Фамилия студента
 - Номер группы
 - Средний балл
 - Адрес проживания
 - Дата рождения

### Ограничения
Некоторые атрибуты необходимо ограничить, чтобы исключить вероятные ошибки при заполнении таблицы. Применяем следующие ограничения:
 - Имя не может быть пустым - минимальная запись будет выглядеть как номер зачетки и имя студента
 - Средний балл от 2 до 5 - предполагаем, что единицы как оценки не ставятся
 - Номер группы от 1000 до 9999 - он создается по схеме `{курс:1}{номер направления:2}{номер группы:1}`. Соответственно, состоит ровно из четырех цифр. Вряд ли будет существовать девятый курс, поэтому можно ограничить максимальное значение чуть ниже, но пока оставим так
 - Ограничиваем максимальную длину имени, фамилии и адреса - крайне низкая вероятность превышения данного лимита, но хорошее ограничение против вставки слишком большого количества неверной информации
 - Номер зачетки имеет тип *отличный от `SERIAL`*, так как принадлежит некоему определенному студенту, а не просто выполняет функцию номера строки. Если таблица будет главной в работе, а не заполняться данными извне, то можно использовать `SERIAL`

Используем следующий код для создания таблицы:
```SQL
CREATE TABLE "students" (
	"n_z" INTEGER NOT NULL,
	"name" VARCHAR(255) NOT NULL,
	"surname" VARCHAR(255) NULL DEFAULT NULL,
	"group_num" INTEGER NULL DEFAULT NULL,
	"score" NUMERIC(3,2) NULL DEFAULT NULL,
	"address" VARCHAR(2000) NULL DEFAULT NULL,
	"date_of_birth" DATE NULL DEFAULT NULL,
	PRIMARY KEY ("n_z"),
	CONSTRAINT "group_num" CHECK ((((group_num <= 9999) AND (group_num >= 1000)))),
	CONSTRAINT "score" CHECK ((((score >= (2)::numeric) AND (score <= (5)::numeric))))
);
```

## Хобби
Затем создаем таблицу с возможными хобби. Первичный ключ - идентификатор хобби.  
### Атрибуты
 - ID хобби
 - Название
 - Фактор риска

### Ограничения
 - Фактор риска находится в диапазоне от 0 до 10

Используем следующий код для создания таблицы:
```SQL
CREATE TABLE "hobby" (
	"id" INTEGER NOT NULL DEFAULT 'nextval(''hobby_id_seq''::regclass)',
	"name" VARCHAR(255) NOT NULL,
	"risk" NUMERIC(4,2) NULL DEFAULT NULL,
	PRIMARY KEY ("id"),
	CONSTRAINT "risk" CHECK ((((risk >= (0)::numeric) AND (risk <= (10)::numeric))))
);
```
> `INTEGER NOT NULL DEFAULT 'nextval(''hobby_id_seq''::regclass)'` соответствует типу `SERIAL`. По неизвестным причинам, используемый клиент не может применить тип `SERIAL`, выдавая ошибку

## Хобби студентов
Наконец, создаем таблицу, содержащую в себе связи между студентами и хобби, которыми они занимаются. Первичный ключ - идентификатор записи. Два внешних ключа - номер зачетки и ID хобби.

### Атрибуты
 - ID записи
 - Номер зачетки студента (Внешний ключ)
 - ID хобби (Внешний ключ)
 - Время начала
 - Время окончания

### Ограничения
 - Существуют два внешних ключа. Они ограничивают возможность добавления несуществующего студента, или присвоение ему несуществующего хобби. Для каждого из ключей его значение обязательно должно существовать в соответствующей таблице

Используем следующий код для создания таблицы:
```SQL
CREATE TABLE "student_hobby" (
	"id" INTEGER NOT NULL DEFAULT 'nextval(''student_hobby_id_seq''::regclass)',
	"n_z" INTEGER NOT NULL,
	"id_hobby" INTEGER NOT NULL,
	"date_start" TIMESTAMPTZ NULL DEFAULT NULL,
	"date_end" TIMESTAMPTZ NULL DEFAULT NULL,
	PRIMARY KEY ("id"),
	CONSTRAINT "hobby_id" FOREIGN KEY ("id_hobby") REFERENCES "public"."hobby" ("id") ON UPDATE NO ACTION ON DELETE NO ACTION,
	CONSTRAINT "n_z" FOREIGN KEY ("n_z") REFERENCES "public"."students" ("n_z") ON UPDATE NO ACTION ON DELETE NO ACTION
)
```

# Заполняем таблицы
## Студенты
Начнем с заполнения таблицы со студентами. Удобно использовать [скрипт](dbfill.py), который автоматически заполнит таблицу случайными данными.  
Для добавления данных в таблицу используется запрос ниже, где `%s` - некоторое значение, задаваемое скриптом.
```SQL
INSERT INTO "students" (
    "n_z", 
    "name", 
    "surname", 
    "group_num", 
    "score", 
    "date_of_birth"
) 
VALUES 
    (%s,%s,%s,%s,%s,%s)
```
В результате получаем таблицу студентов, заполненную случайными данными:  
![Таблица со студентами](Students_Table.png)

## Хобби
Для того, чтобы таблица с хобби содержала похожие на правду данные, ее необходимо заполнить вручную.  
Получаем следующую таблицу:  
![Таблица с хобби](Hobby_Table.png)

## Сопоставление студентов с хобби
Данная таблица тоже заполняется автоматически с помощью вышеупомянутого [скрипта](dbfill.py). Для вставки берется случайный студент, случайное хобби, создаются случайные даты начала и окончания, после чего с помощью SQL - запроса, приведенного ниже, данные добавляются в таблицу. Так как мы берем существующие ID студента и хобби, условия внешних ключей удовлетворяются.
```SQL
INSERT INTO "student_hobby" (
    "n_z", 
    "id_hobby", 
    "date_start", 
    "date_end"
) 
VALUES 
    (%s,%s,%s,%s)
```
> `date_end` может быть `NULL` - это означает то, что студент все еще занимается этим хобби на данный момент

Получаем следующую таблицу:  
![Таблица ассоциаций](Student_Hobby.png)

# Заключение
В результате выполненных действий мы получили:  
 - Таблицу данных о студентах
 - Таблицу существующих хобби
 - Таблицу ассоциаций между студентами и хобби, которыми они занимаются

Также мы заполнили эти таблицы случайными данными.  
Теперь можно исполнять запросы выбора, модификации, или удаления строк.